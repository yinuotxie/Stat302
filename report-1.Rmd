---
title: "SVD Analysis of Partisanships and Voting Pattern in the U.S Congress."
author: "Travis Xie"
date: "2/18/2020"
output: 
  html_document:
    theme: paper
---
<!--- Begin styling code. --->
<style type="text/css">
/* Whole document: */
body{
  font-family: "Palatino Linotype", "Book Antiqua", Palatino, serif;
  font-size: 12pt;
  text-align: justify
}
h1.title {
  font-size: 38px;
  text-align: center;
}
h4.author {
  font-size: 18px;
  text-align: center;
}
h4.date {
  font-size: 18px;
  text-align: center;
}

p1 {
  font-size: 8pt
}
</style>
<!--- End styling code. --->

# Introduction:
Most of the time, the U.S Congress is composed of two parties, Democratic and Republican. Sometimes a few representatives from other parties may be elected, but they barely have any influence in making policies. Therefore, many people will simply assume that the partisanship is apparent in congress – democrats vote together with democrats and republicans vote together with republicans.  Is this assumption true in all the Congress that the U.S has held? Are there any other factors that contribute to partisanship? This report aims to answers these questions by using a singular value decomposition(SVD) method to analyze partisanship and voting patterns in 90th and 116th U.S congress.


## Partisanship Pattern
To uncover the partisanship pattern,  I use singular value decomposition(SVD) of voting records of the 90th and 116th U.S. congress. Since the same method is applied in each case this report presents, here I will only explain the analyzing process of 116th houses as an example. First, I define an $m*n$ voting matrix **A**,  with *m* representatives in each row and *n* roll-call votes in each column. The 116th house (the latest house) has $m = 439$ representatives from three parties -- Democratic, Republican, and Independent -- and has already voted $n = 733$ roll-calls at the time when I downloaded the data. The element $A_{ij}$ is 1, if Representative *i* voted ‘‘yea’’ on vote *j* and -1 if he or she voted ‘‘nay.’’. If a Representative did not vote because of absence or abstention, the corresponding element is 0[^1]. The SVD helps to identify groups of representatives who often voted together. It decomposes the matrix **A** in the following two ways: <br>
$$A = UDV^T$$
where U represents left singular vectors, V represents right singular vectors, and D represents a diagonal matrix whose diagonal lies all the singular values[^2] or, 
$$A_i = \sum_{i}^k \sigma_i u_i v_i^T$$ 
where $\sigma_i$ is the *ith* sigular value,  $u_i$ is the *ith* colums of **u**, $v_i$ is *ith* columns of **v**, **k** is the best rank of matrix **A**. The primary purpose of SVD is to simplify calcucation. It can reduce the dimension of a matrix while keeping most of the data. To know exactly how many dimensions can be reduced, we need to assess the total energy of matrix A by the equation below:
$$energy(A) = \sum_{i}^n\sigma_i^2$$
Then, we can say that each term accounts for a fraction of $\sigma_i^2/energy(A)$. The table below shows how much proportion of energy that the first 10 leading term each accounts for. 

```{r echo=FALSE}
library(knitr)
library(kableExtra)
library(gapminder)
energy <- read.csv(file = "./Data/energy.csv")
energy %>%
  kable() %>%
  kable_styling(full_width = TRUE) %>%
  row_spec(1:2, bold = TRUE, color = "white", background = "red") %>%
  scroll_box(height = "220px") %>%
  footnote(general_title = "Note: ",
           general = "The first column gives us the ith term. The second column gives us the fraction that each term accounts for. The third column gives us the cumulative fraction that first i terms   account for.",
           footnote_as_chunk = TRUE,
           title_format = c("bold"))
```
<br>
In the table, we can perceive that the first leading term accounts for around 60% percent of energy, and the second leading term accounts for 24%. None of the rest terms account for more than 1.6%. Thus, to an excellent approximation, the matrix A can be by only the first two leading terms, namely:
$$A= \sigma_1 u_1 v_1^T + \sigma_2 u_2 v_2^T$$
This is not the only case that the first two leading terms can explain more than 80% of the data. The similar results are attained in all cases that this report addresses.

### Partisanship in 90th and 116 houses {.tabset}
By using the first two leading terms, I successfully plot the following figures to show the partisanship in the 90th house and 116th house.  When I make the plots, I surprisingly notice that the distribution of the representative is profoundly consistent with the acknowledged political party affiliation of representatives, with Democratic shown in blue, Republican in red, and Independent in green. Accordingly,  I denote the x-axis as "partisan coordinate" and y-axis as "bipartisan coordinate". Representatives who score high[^3] on the partisan coordinate are more likely to vote with their party.

#### 90th Houses
```{r echo=FALSE, fig.align = "center", out.height="60%", out.width="60%"}
knitr::include_graphics("./Figure/pattern_90.png")
```
<br>
Many People assume that representatives from the same party favor to vote together. However, the partisanship in 90th houses partially declines this assumption. The figure shows all Democrats in blue and Republicans in red. We can observe the distribution of Democrats spread out more than Republicans. A large portion of Republicans votes with the party with only a few exceptions. While, in contrast,  as large as one-third of the Democrats vote with the opposite party. To figure out what contributes to this partisanship, I did a little bit of research. I found out that back to 90th congress, the Democratic was the majority party in the house and senate and they controlled 67% of the senate and 57% of the houses.  With this large controls of seats, democrats could easily pass the bills without considering too much about Republicans. Therefore, when it came to trivial votes, members of Democratic had more freedom to choose their positions. 

#### 116th Houses
```{r echo=FALSE, fig.align = "center", out.height="60%", out.width="60%"}
knitr::include_graphics("./Figure/pattern_116.png")
```
<br>
The 116th house agrees with the assumption. In the figure, we can observe the partisanship. In contrast to the 90th house, almost all representatives, no matter which party they belong to, will vote with their party. Additionally, we can see that the range of partisanship scales in the 116th house is larger than in the 90th house. Thus, representatives are more partisan nowadays. Looking close to the figure, we can find that a few representatives from different parties seem to like to vote together -- their names are labeled out. What makes them so special? After searching their names online and in the original database, I found out the answer. They tend to vote together and be less partisan because they all have many absences in roll-call votes. Nancy Pelosi, as the speaker of the U.S, is probably too busy to attend roll-call votes. Walter Jones died in 2019. Thomas Mario resigned from the house in January 2019. Jefferson Van Drew just joined in the Republican party this year. And, Justin Amash became an independent from Republican after calling for the impeachment of Donald Trump. No wonder these people have very low partisanship scores and are very close to bipartisan.

## Contributing factors to Partisanship
Are there any other factors that contribute to the partisanship besides the party? In the following sections, I  examine two other factors, generation, and region, and discuss whether they have influence in the partisanship of the representatives.

### 1. Partishanship by Generation
A generation is defined as "all of the people born and living at about the same time, regarded collectively." It can also be described as, "the average period, generally considered to be about **thirty** years, during which children are born and grow up, become adults, and begin to have children of their own[^4]. In other words, people belonging to the same generation have a high likelihood to face similar life crises. As a result, they may develop common opinions toward politics. Then, a question arises. Do representatives in the same generation tend to vote together?
To answer this question, I first categorize the representative by the definition of generation, namely, people born in the same span of 30 years belong to the same generation. Then, I denote a matrix **B** to represent how likely people vote together.
$$B = AA^T$$
The next step is to use SVD methods to decompose the matrix **B**. The process has already been shown in the previous section, so I will skip it here. The figures below are plotted after applying SVD.

***

```{r echo=FALSE}
knitr::include_graphics("./Figure/partisan_generation.png")
```
<p1>Note: The figure denotes (+) as Democratic, (*) as Independent, and (x) as Republican.  Furthermore, it marks the 1st generation in blue and the 2nd generation in blue.  Representatives that are on the right of the have partisanship in Democratic and those on the left have partisanship in Republican. </p1>

***

The figure has already given us the answer.  It is obvious to notice that representatives are clustered together by their parties, not by their generation. This suggests that generation is not a significant factor for representatives to decide which party to vote with.

### 2. Partisanship by Region
Traditionally, many use five major regions when dividing up the U.S states. They are the Northeast, Southeast, Midwest, Southwest, and West. Each region has its unique geography and culture. Does partisanship also exist in each region?  To answer the question, representatives are divided into 5 regions[^5] based on their states. Then, I make a violin chart to demonstrate the partisanship in each region.
<br>
```{r echo=FALSE, fig.align = "center", out.height="70%", out.width="70%"}
knitr::include_graphics("./Figure/region.png")
```
<br>
In the plot of Partisanship in 116th House, we know that Democrats tend to have negative numbers and Republicans have positive numbers. This is also true for the violin chart since they are from the same dataset. In the figure, we can observe that the West and the Northeast have a bigger area in negative numbers (Democratic). The Southwest and the Southeast have a bigger area in positive numbers. And, The Midwest has a slightly bigger area in positive numbers as well. These findings are consistent with the midterm election result in 2019. They also suggest that partisanship varies in each region. Besides, if Donald Trump wants to be the president again, he has to put lots of effort into gaining ballots in the Midwest.

## Roll-Call Vote Pattern
Not only can the SVD method show us the clustering of representatives, but it can also let us know the distribution pattern of roll-call votes. The decomposition process has already been introduced in the second paragraph, so here I will only present the energy table to show how much data is preserved by the first two leading terms. The data I used here is also from 116th congress, so I expect the energy table should be the same.
<br>
```{r echo=FALSE}
energy1 <- read.csv(file = "./Data/energy1.csv")
energy1 %>%
  kable() %>%
  kable_styling(full_width = TRUE) %>%
  row_spec(1:2, bold = TRUE, color = "white", background = "red") %>%
  scroll_box(height = "220px") %>%
  footnote(general_title = "Note: ",
           general = "The first column gives us the ith term. The second column gives us the fraction that each term accounts for. The third column gives us the cumulative fraction that first i terms   account for.",
           footnote_as_chunk = TRUE,
           title_format = c("bold"))
```

***

The following graph displays the pattern of the roll-call votes and marks bills passed in red and rejected in blue.
```{r echo=FALSE, fig.align = "center", out.height="70%", out.width="70%"}
knitr::include_graphics("./Figure/vote.png")
```
<br>
Unfortunately, in the roll calls of 116th house, I am not able to identify the coordinates, given my limited expertise. But, we can easily recognize the voting pattern of bills. Bills that passed tend to be at the bottom half, tilting a little bit to right, and bills that are rejected are in the other half.  The reason behind this distribution pattern needs other methods to uncover.

## Conclusions:
To conclude,  an SVD analysis of roll-call votes is demonstrably useful in analyzing partisanship and voting pattern in the U.S. Congress. I successfully found clusters of congress representatives, their corresponding partisanship, and distribution pattern of roll-call votes, without much knowledge of U.S politics. By comparing partisanship in 90th and 116 houses, my analysis strongly suggests that representatives are more partisan these days. To figure out whether this trend will continue to the future, more data are needed to reveal the changes of partisanship after the 90th congress. Moreover,  my analysis suggests that partisanship varies in regions but not in ages(or generations) of representatives. SVD is a powerful method, however, it does not help define the coordinates of the data. I hope that additional studies can provide other aspects of partisanship and the voting pattern in the U.S. Congress and solve the problems I encounter in the report. 

[^1]: In order to process the data as a matrix, I convert all the "NA", representing absence, to 0.
[^2]: U means representatives-to-concept. V means roll-call votes-to-concept. D means the power of each concept.
[^3]: The score of partisanship is the absolute value of partisan coordinate.
[^4]: Source from "https://en.wikipedia.org/wiki/Generation".
[^5]: States are categorized to region in the following way: Northeast: Maine, Massachusetts, Rhode Island, Connecticut, New Hampshire, Vermont, New York, Pennsylvania, New Jersey, Delaware, Maryland; Southeast: Washington D.C, West Virginia, Virginia, Kentucky, Tennessee, North Carolina, South Carolina, Georgia, Alabama, Mississippi, Arkansas, Louisiana, Florida; Midwest: Ohio, Indiana, Michigan, Illinois, Missouri, Wisconsin, Minnesota, Iowa, Kansas, Nebraska, South Dakota, North Dakota; Southwest: Texas, Oklahoma, New Mexico, Arizona; West: Colorado, Wyoming, Montana, Idaho, Washington, Oregon, Utah, Nevada, California, Alaska, Hawaii.

***

## Appendix Code
```{r appendix, eval=FALSE, echo=TRUE, message=FALSE, warning=FALSE}
library(tidyverse)
library(gapminder)
library(ggplot2)
library(dplyr)
library(ggrepel)
library(ggpubr)
library(knitr)
library(gghighlight)
library(viridis)

# download the data from websites
house_90th <- read.csv("https://raw.githubusercontent.com/bryandmartin/STAT302/master/docs/Projects/project2/house_90_raw.csv")
senate_90th <- read.csv("https://raw.githubusercontent.com/bryandmartin/STAT302/master/docs/Projects/project2/senate_90_raw.csv")
house_116th <- read.csv("https://raw.githubusercontent.com/bryandmartin/STAT302/master/docs/Projects/project2/house_116_raw.csv")
senate_116th <- read.csv("https://raw.githubusercontent.com/bryandmartin/STAT302/master/docs/Projects/project2/senate_116_raw.csv")

write.csv(house_90th, file = "./Data/house_90th.csv")
write.csv(senate_90th, file = "./Data/senate_90th.csv")
write.csv(house_116th, file = "./Data/house_116th.csv")
write.csv(senate_116th, file = "./Data/senate_116th.csv")

# reload all the data needed
house_90th <- read.csv("./Data/house_90th.csv", stringsAsFactors = FALSE)
senate_90th <- read.csv("./Data/senate_90th.csv", stringsAsFactors = FALSE)
house_116th <- read.csv("./Data/house_116th.csv", stringsAsFactors = FALSE)
senate_116th <- read.csv("./Data/senate_116th.csv", stringsAsFactors = FALSE)

# This fuction replaces all NA in the data to 0, select all columns that start
# with "rc", and then convert the data into a matrix
my_matrix <- function(data) {
  data <- data %>%
    mutate_all(~replace(., is.na(.), 0)) %>%
    select(starts_with("rc")) %>%
    as.matrix() 
  return(data)

# This function uses svd method to reduce the dimension of the input data
# and draw a plot 
pattern <- function(data) {
  # convert the data to a matrix
  data_matr <- my_matrix(data)
    
  # use svd to decompose the data, setting the concept to 2
  # U is representative to concept
  # V is roll call to concept
  decomp <- svd(data_matr)
  
  # representative-to-concept score
  partisan <- data_matr %*% decomp$v 
  
  # make the partisan matrix to data frame for plotting 
  partisan_df <- data.frame("x" = partisan[, 1],
                            "y" = partisan[, 2],
                            "party" = data$party_code,
                            "name" = data$bioname)
  # plot 
  plot <- partisan_df %>%
    ggplot(aes(x = x, y = y, color = party)) +
    geom_point() + 
    scale_color_manual(name = "Party",
                       values = c("D" = "blue", "R" = "red", "I" = "green")) +
    theme_classic() +
    # face = bold italic
    theme(plot.title = element_text(hjust = 0.5, face = 4, size = 20),
          axis.title = element_text(hjust = 0.5, vjust = 0.6, size = 16),
          axis.text = element_text(size = 10),
          panel.background = element_rect(fill = "floralwhite"),
          legend.title = element_text(size = 12),
          legend.text = element_text(size = 10))
  
  # extract the name of the data
  name <- deparse(substitute(data))
  
  # if the data is 116th congress, add another layer
  if (grepl(116, name)) {
    plot <- plot +  
      # Filter data first
      geom_text_repel(data = partisan_df 
                      %>% filter(x > -5 & x < 5 & y > -2.5 & y < 2.5), 
              aes(label = name), 
              size = 4)
  } 
  
  return(plot)
}

h_r_90 <- pattern(house_90th) +
  labs(title = "Partisanship in 90th House", x = "bipartisan", y = "partisan") +
  # flip the coordinate to make two plot consistent in coordinates
  coord_flip() +
  theme(legend.position = "right")

h_r_116 <- pattern(house_116th) +
  # add labels
  labs(title = "Partisanship in 116th House", x = "partisan", y = "bipartisan") +
  theme(legend.position = c(.2, .35),
        legend.justification = c("right", "top"),
        legend.box.just = "right",
        legend.margin = margin(6, 6, 6, 6),
        legend.box.background = element_rect(colour = "cyan"))

# This function helps to categorize data by generation
# using the concept that a generation = 30 years
generation <- function(data) {
  # get all the year in which representatives were born
  born <- sort(data$born)
  
  # create the ouput matrix, row = i generation, col = years in ith generation
  # the number of generation isn't possible to go over 4 (120 years)
  generation_matrix <- matrix(NA, nrow = 4, ncol = 30)
  
  # first = first year in ith generation
  first <- born[1]
  # last = last year in ith generation
  last <- first + 29
  # for loop the generation
  for (i in 1:4) {
    generation_matrix[i, ] <- c(first:last)
    # update the first
    first <- last + 1
    # updata the last
    last <- first + 29
  }
  
  # categorize data by generation
  data <- data %>%
    mutate(generation = ifelse(born %in% generation_matrix[1, ], "1", 
                        ifelse(born %in% generation_matrix[2, ], "2",
                        ifelse(born %in% generation_matrix[3, ], "3", "4"))))
  return(data)
}

by_generation <- function(data) {
  
  # categorize data by generation
  data <- generation(data)
  
  # convert the data to a matrix
  data_matr <- my_matrix(data)
  
  # how likely two people vote together
  data_matr <- data_matr %*% t(data_matr)
  
  # svd decompostion
  decomp <- svd(data_matr)
  
  partisan_df <- data.frame("x" = decomp$u[, 1],
                            "y" =  decomp$u[, 2],
                            "generation" = data$generation,
                            "party" = data$party_code)
  
  plot <- partisan_df %>%
    ggplot(aes(x = x, y = y, color = generation)) +
    geom_point(aes(shape = party), size = 1.8) +
    scale_shape_manual(name = "Party",
                       labels = c("Democratic", "Independent", "Republican"),
                       values = c("D" = 3, "R" = 4, "I" = 8)) +
    scale_color_manual(name = "Generation",
                       labels = c("1st", "2rd", "3nd", "4th"),
                       values = c("1" = "gold", "2" = "blue", 
                                  "3" = "red", "4" = "green")) +
    theme_classic() +
    theme(plot.title = element_text(hjust = 0.5, face = 4, size = 20),
          axis.title = element_text(hjust = 0.5, vjust = 0.6, size = 16),
          axis.text = element_text(size = 10),
          panel.background = element_rect(fill = "floralwhite"),
          legend.title = element_text(size = 12),
          legend.text = element_text(size = 10),
          legend.background = element_rect(color = "cyan"))
  
  return(plot)
}

h_g_116 <- by_generation(house_116th) +
  labs(x = "partisan", y = "bipartisan")

s_g_116 <- by_generation(senate_116th) +
  labs(x = "partisan", y = "bipartisan")

partisan_generation <- ggarrange(h_g_116, s_g_116,
                                 labels = c("116th house", "116th senate"),
                                 font.label = list(size = 12, face ="italic", 
                                                    color = "green"),
                                 hjust = -1, 
                                 nrow = 1, ncol = 2,
                                 align = "hv", common.legend = TRUE, 
                                 legend = "top")

# This function helps to category input data by geographic region of USA
region <- function(data) {
  # create 5 vectors that represents 5 regions of USA
  # no need to create the last region, since whatever left over belongs to it
  west <- c("WA", "OR", "ID", "MT", "WY", "CA", "NV", "UT", "CO", "AK", "HI")
  midwest <- c("ND", "SD", "NE", "KS", "MN", "IA", "MO", "WI", "IL", "MI", "IN",
             "OH")
  southwest <- c("AZ", "NM", "OK", "TX")
  southeast <- c("AR", "LA", "KY", "TN", "MS", "AL", "WV", "DC", "VA", "NA", "SC",
              "GA", "FL", "MD", "DE")
  #northeast <- c("ME", "NT", "NH", "MA", "RI", "CT", "NJ", "NY", "DA")
  
  # output data
  output <- data %>%
    # categories the data 
    mutate(region = ifelse(state_abbrev %in% west, "west",
                    ifelse(state_abbrev %in% midwest, "midwest",
                    ifelse(state_abbrev %in% southwest, "southwest",
                    ifelse(state_abbrev %in% southeast, "southeast", "northeast")))))
  return(output)
}

# This function helps to plot the graph that displays the partisanship in 
# different regions
by_region <- function(data) {
  
  # categorize the data by regions
  data <- region(data)
  
  # convert data frame to matrix
  data_matr <- my_matrix(data)
  
  # svd decompostion
  decomp <- svd(data_matr)
  
  # caculate partisan-to-concept score
  partisan <- data_matr %*% decomp$v
  
  # convert it back to data frame in order to plot
  partisan_df <- data.frame("score" = partisan[, 1], "region" = data$region)
  
  plot <- partisan_df %>%
    group_by(region) %>%
    ggplot(aes(x = region, y = score, fill = region))  +
    geom_violin() +
    scale_fill_viridis(discrete = TRUE, alpha=0.6, option="A") +
    theme_classic() +
    theme(legend.position="none",
          plot.title = element_text(hjust = 0.5, face = 4, size = 20),
          axis.title = element_text(hjust = 0.5, vjust = 0.6, size = 12),
          axis.text = element_text(size = 10)) +
    coord_flip() +
    labs(title = "Partisanship by Region in 116th House",
         x = "Region", y = "partisanship")
    
  return(plot)
}

region_plot<- by_region(house_116th)

# This function gets the plot of voting pattern
rollCall <- function(data) {
  
  data <- my_matrix(data)
  
  # create the status: whether each roll call is passed or rejected
  status <- matrix(NA, nrow = ncol(data), ncol = 1)
    for (i in 1:ncol(data)) {
      yes <- sum(data[, i] > 0)
      nay <- sum(data[, i] < 0)
      ration <- yes / (yes + nay)
      status[i, 1] <- ifelse(ration > 0.5, "Pass", "Reject")
    }
  
  status <- tibble("status" = status[, 1])

  # flip rows and columns
  # rows: roll calls
  # cols: representatives
  data <- t(data) 
  
  # svd     
  decomp <- svd(data)
  
  # roll-to-concept score
  rc_2_c <- data %*% decomp$v
  rc_df <- data.frame("x" = rc_2_c[, 1],
                      "y" = rc_2_c[, 2])
  
  plot <- rc_df %>%
    ggplot(aes(x = x, y = y, color = status$status)) +
    geom_point() +
    labs(title = "Voting Pattern in 116th House", color = "Status", x = "", y = "") +
    theme_classic() +
    theme(plot.title = element_text(hjust = 0.5, face = 4, size = 20),
          axis.title = element_text(hjust = 0.5, vjust = 0.6, size = 16),
          axis.text = element_text(size = 10),
          panel.background = element_rect(fill = "floralwhite"),
          legend.title = element_text(size = 12, hjust = 0.5),
          legend.text = element_text(size = 10),
          legend.background = element_rect(color = "cyan"))
}

vote <- rollCall(house_116th)

# This function creates a table that shows how much energy each term account for
# Input: data, transpose: whether to transpose the data
energy_frac <- function(data, transpose = FALSE) { 
  
  # convert the data to a matrix
  data_matr <- my_matrix(data)
  
  # transpose the matrix if transpose == TRUE
  if(transpose) {
    data_matr <- t(data_matr)
  }
  
  # use svd to decompose the data
  decomp <- svd(data_matr)
  
  # calculate the total energy
  energy <- sum(decomp$d^2)
  
  # ouput matrix
  fraction <- matrix(0, nrow = 10, ncol = 2) 
  
  for (i in 1:nrow(fraction)) {
    fraction[i, 1] <- decomp$d[i]^2 / energy
    # calculate cumulative fraction
    # the first term has cumulative fraction of itself
    if (i == 1) {
      fraction[i, 2] <- fraction[i, 1]
    } else {
      # cum fraction = fraction + the fraction of the last term
      fraction[i, 2] <- fraction[i, 1] + fraction[i - 1, 2]
    }
  }
  
  # output dataframe
  fraction <- data.frame("fraction" = fraction[, 1], 
                         "cumulative_fraction" = fraction[, 2])
  
  return(fraction)
}

# get the energy table
energy <- energy_frac(house_116th)
energy1 <- energy_frac(house_116th)

# save the energy table as csv file

write.csv(energy, file = "./Data/energy.csv")
write.csv(energy1, file = "./Data/energy1.csv")

# save the plots as png file
ggsave(filename = "./Figure/pattern_90.png", h_r_90, height = 7, width = 7)
ggsave(filename = "./Figure/pattern_116.png", h_r_116, height = 7, width = 7)
ggsave(filename = "./Figure/partisan_generation.png", partisan_generation,
       width = 12, height = 8)
ggsave(filename = "./Figure/vote.png", vote, height = 5, width = 7)
ggsave(filename = "./Figure/region.png", region_plot, height = 5, width = 7)
```

